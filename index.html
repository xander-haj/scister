<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OCR Image Processor with Clickable Text Highlights</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Tesseract.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            color: #333;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 15px;
        }
        p {
            margin-bottom: 15px;
        }
        .input-section {
            margin-bottom: 20px;
        }
        .input-section label {
            display: block;
            margin: 10px 0 5px 0;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        #controls button {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            color: #fff;
        }
        #draw-button {
            background-color: #8e44ad;
        }
        #perform-ocr {
            background-color: #2cb67d;
        }
        #clear-image {
            background-color: #d00000;
        }
        #imageInput {
            flex: 1 1 200px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #imageContainer {
            position: relative;
            display: inline-block;
            margin-top: 10px;
            padding: 0;
            max-width: 100%;
            touch-action: none; /* Prevent default touch actions */
        }
        #uploadedImage {
            max-width: 100%;
            border: 1px solid #ddd;
            display: block;
        }
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: auto;
            /* Removed width and height to manage via JavaScript */
        }
        #statusMessage {
            font-size: 14px;
            color: #555;
            margin-top: 10px;
        }
        #fieldContainer {
            margin-top: 20px;
        }
        #fieldContainer label {
            font-weight: bold;
            margin: 10px 0 5px 0;
        }
        #fieldContainer input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .buttons-container {
            margin-top: 20px;
        }
        .buttons-container button {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            margin-right: 10px;
            color: #fff;
        }
        #update-table {
            background-color: #3498db;
        }
        #save-csv {
            background-color: #f39c12;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }
        table, th, td {
            border: 1px solid #ccc;
        }
        th, td {
            padding: 8px;
            text-align: left;
            font-size: 14px;
        }
        th {
            background: #f2f2f2;
            font-weight: bold;
        }

        /* Mobile Responsive Adjustments */
        @media (max-width: 600px) {
            #controls {
                flex-direction: column;
                align-items: stretch;
            }
            .buttons-container button {
                width: 100%;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>OCR Image Processor with Clickable Text Highlights</h1>
    <p>Upload an image and perform OCR. Recognized words will be highlighted in light blue on the image. Use the "Draw" tool to select specific words you want to process. Click on a highlighted area to assign the grouped text to one of the input fields (Item Name Short, Item Name Long, UPC, Location, Downstack, Notes). You can edit fields manually as well. Once done, press "Update Table" to add a row to the table. Process multiple images by clearing the image and fields. Finally, press "Save CSV" to download all collected data.</p>

    <div class="input-section">
        <div id="controls">
            <input type="file" id="imageInput" accept="image/*">
            <button id="draw-button">Draw</button>
            <button id="perform-ocr">Perform OCR</button>
            <button id="clear-image">Clear Image & Fields</button>
        </div>
        <div id="imageContainer" style="display:none;">
            <img id="uploadedImage" alt="Uploaded Image">
            <canvas id="overlayCanvas"></canvas>
        </div>
        <p id="statusMessage"></p>
    </div>

    <div id="fieldContainer">
        <label for="field1">Item Name Short:</label>
        <input type="text" id="field1">
        <label for="field2">Item Name Long:</label>
        <input type="text" id="field2">
        <label for="field3">UPC:</label>
        <input type="text" id="field3">
        <label for="field4">Location:</label>
        <input type="text" id="field4">
        <label for="field5">Downstack:</label>
        <input type="text" id="field5">
        <label for="field6">Notes:</label>
        <input type="text" id="field6">
    </div>

    <div class="buttons-container">
        <button id="update-table">Update Table</button>
        <button id="save-csv">Save CSV</button>
    </div>

    <table id="dataTable">
        <thead>
            <tr>
                <th>Item Name Short</th>
                <th>Item Name Long</th>
                <th>UPC</th>
                <th>Location</th>
                <th>Downstack</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <!-- Rows will be appended here -->
        </tbody>
    </table>

    <script>
        const imageInput = document.getElementById('imageInput');
        const uploadedImage = document.getElementById('uploadedImage');
        const imageContainer = document.getElementById('imageContainer');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const performOcrButton = document.getElementById('perform-ocr');
        const clearImageButton = document.getElementById('clear-image');
        const drawButton = document.getElementById('draw-button');
        const statusMessage = document.getElementById('statusMessage');
        const dataTable = document.getElementById('dataTable').querySelector('tbody');

        const field1 = document.getElementById('field1');
        const field2 = document.getElementById('field2');
        const field3 = document.getElementById('field3');
        const field4 = document.getElementById('field4');
        const field5 = document.getElementById('field5');
        const field6 = document.getElementById('field6');

        const updateTableButton = document.getElementById('update-table');
        const saveCsvButton = document.getElementById('save-csv');

        let currentWords = []; // Store recognized words with their bounding boxes
        let imageDataURL = null; // For OCR
        let drawMode = false; // Indicates if draw mode is active
        let isDrawing = false; // Indicates if the user is currently drawing
        let startX = 0;
        let startY = 0;
        let currentRect = null; // Current rectangle being drawn
        let selectedBlocks = []; // Array to store selected blocks

        // Event Listener for Image Upload
        imageInput.addEventListener('change', () => {
            const file = imageInput.files[0];
            if (!file) {
                resetImageDisplay();
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedImage.src = e.target.result;
                uploadedImage.onload = () => {
                    imageContainer.style.display = 'inline-block';
                    
                    // Set the canvas size to match the displayed image size
                    overlayCanvas.width = uploadedImage.clientWidth;
                    overlayCanvas.height = uploadedImage.clientHeight;

                    clearCanvas();
                    statusMessage.textContent = 'Image loaded. Click "Perform OCR" to proceed.';
                    imageDataURL = e.target.result;
                };
            };
            reader.readAsDataURL(file);
        });

        // Event Listener for Perform OCR Button
        performOcrButton.addEventListener('click', async () => {
            if (!imageDataURL) {
                alert('Please select an image first.');
                return;
            }
            statusMessage.textContent = 'Performing OCR... please wait.';
            clearCanvas();
            currentWords = [];
            selectedBlocks = [];
            const textData = await runOCR(imageDataURL);
            statusMessage.textContent = 'OCR complete. Use the "Draw" tool to select specific text.';
            // Optionally, you can auto-highlight all words if needed
            // drawWords(textData);
        });

        // Event Listener for Clear Image Button
        clearImageButton.addEventListener('click', () => {
            resetImageDisplay();
            resetFields();
            clearCanvas();
            selectedBlocks = [];
            statusMessage.textContent = 'Cleared image and fields. Table is preserved. You can upload a new image.';
        });

        // Event Listener for Draw Button
        drawButton.addEventListener('click', () => {
            if (!currentWords.length && selectedBlocks.length === 0) {
                alert('Please perform OCR first.');
                return;
            }
            drawMode = !drawMode;
            drawButton.style.backgroundColor = drawMode ? '#6c3483' : '#8e44ad';
            drawButton.textContent = drawMode ? 'Cancel Draw' : 'Draw';
            statusMessage.textContent = drawMode ? 'Draw mode activated. Draw a rectangle on the image.' : 'Draw mode deactivated.';
        });

        // Event Listener for Overlay Canvas Click (for selecting blocks)
        overlayCanvas.addEventListener('click', (e) => {
            if (drawMode) return; // Ignore clicks when in draw mode
            const rect = overlayCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (let block of selectedBlocks) {
                if (x >= block.x && x <= block.x + block.width && y >= block.y && y <= block.y + block.height) {
                    assignBlockToField(block.text);
                    break;
                }
            }
        });

        // Touch Events for Mobile Drawing
        overlayCanvas.addEventListener('touchstart', (e) => {
            if (!drawMode) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = overlayCanvas.getBoundingClientRect();
            startX = touch.clientX - rect.left;
            startY = touch.clientY - rect.top;
            isDrawing = true;
            currentRect = { x: startX, y: startY, width: 0, height: 0 };
        });

        overlayCanvas.addEventListener('touchmove', (e) => {
            if (!drawMode || !isDrawing) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = overlayCanvas.getBoundingClientRect();
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            currentRect.width = mouseX - startX;
            currentRect.height = mouseY - startY;
            drawCanvasWithCurrentRect();
        });

        overlayCanvas.addEventListener('touchend', (e) => {
            if (!drawMode || !isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            processSelection(currentRect);
            currentRect = null;
        });

        // Mouse Events for Desktop Drawing
        overlayCanvas.addEventListener('mousedown', (e) => {
            if (!drawMode) return;
            e.preventDefault();
            const rect = overlayCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            isDrawing = true;
            currentRect = { x: startX, y: startY, width: 0, height: 0 };
        });

        overlayCanvas.addEventListener('mousemove', (e) => {
            if (!drawMode || !isDrawing) return;
            e.preventDefault();
            const rect = overlayCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            currentRect.width = mouseX - startX;
            currentRect.height = mouseY - startY;
            drawCanvasWithCurrentRect();
        });

        overlayCanvas.addEventListener('mouseup', (e) => {
            if (!drawMode || !isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            processSelection(currentRect);
            currentRect = null;
        });

        // Update Table Button
        updateTableButton.addEventListener('click', () => {
            const row = document.createElement('tr');
            const cols = [field1.value.trim(), field2.value.trim(), field3.value.trim(), field4.value.trim(), field5.value.trim(), field6.value.trim()];
            if (cols.every(c => c === '')) {
                alert('All fields are empty. Nothing to add.');
                return;
            }
            cols.forEach(c => {
                const td = document.createElement('td');
                td.textContent = c;
                row.appendChild(td);
            });
            dataTable.appendChild(row);
            alert('Row added to the table.');
            resetFields();
        });

        // Save CSV Button
        saveCsvButton.addEventListener('click', () => {
            const rows = dataTable.querySelectorAll('tr');
            if (rows.length === 0) {
                alert('No data to save.');
                return;
            }
            const headers = ["Item Name Short", "Item Name Long", "UPC", "Location", "Downstack", "Notes"];
            const data = [headers];

            rows.forEach(r => {
                const cells = r.querySelectorAll('td');
                const rowData = Array.from(cells).map(cell => `"${cell.textContent.replace(/"/g, '""')}"`);
                data.push(rowData);
            });

            const csvContent = data.map(r => r.join(',')).join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ocr_data.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Function to Reset Image Display
        function resetImageDisplay() {
            uploadedImage.src = '';
            imageContainer.style.display = 'none';
            imageDataURL = null;
            clearCanvas();
        }

        // Function to Reset Input Fields
        function resetFields() {
            field1.value = '';
            field2.value = '';
            field3.value = '';
            field4.value = '';
            field5.value = '';
            field6.value = '';
        }

        // Function to Clear Canvas
        function clearCanvas() {
            const ctx = overlayCanvas.getContext('2d');
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        }

        // Function to Run OCR using Tesseract.js
        async function runOCR(dataURL) {
            const worker = await Tesseract.createWorker({
                logger: m => console.log(m)
            });
            await worker.loadLanguage('eng');
            await worker.initialize('eng');
            const { data } = await worker.recognize(dataURL);
            await worker.terminate();
            currentWords = data.words.map(word => ({
                text: word.text.trim(),
                x0: word.bbox.x0,
                y0: word.bbox.y0,
                x1: word.bbox.x1,
                y1: word.bbox.y1
            }));
            return data;
        }

        // Function to Draw Words (Not used in this implementation but kept for reference)
        function drawWords(data) {
            const ctx = overlayCanvas.getContext('2d');
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0, 150, 255, 1)';
            ctx.fillStyle = 'rgba(0, 150, 255, 0.25)';

            // Calculate scaling factors based on the displayed image size
            const scaleX = overlayCanvas.width / uploadedImage.naturalWidth;
            const scaleY = overlayCanvas.height / uploadedImage.naturalHeight;

            if (!data.words) return;

            for (let word of data.words) {
                const { text, bbox } = word;
                if (!text.trim()) continue;

                const x = bbox.x0 * scaleX;
                const y = bbox.y0 * scaleY;
                const w = (bbox.x1 - bbox.x0) * scaleX;
                const h = (bbox.y1 - bbox.y0) * scaleY;

                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);
            }
        }

        // Function to Draw Current Rectangle
        function drawCanvasWithCurrentRect() {
            clearCanvas();
            // Redraw existing selected blocks
            selectedBlocks.forEach(block => {
                drawBlock(block);
            });
            if (currentRect) {
                const ctx = overlayCanvas.getContext('2d');
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(255, 0, 0, 1)';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.25)';
                const rect = normalizeRect(currentRect);
                ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            }
        }

        // Function to Normalize Rectangle (handles negative width/height)
        function normalizeRect(rect) {
            let { x, y, width, height } = rect;
            if (width < 0) {
                x += width;
                width = Math.abs(width);
            }
            if (height < 0) {
                y += height;
                height = Math.abs(height);
            }
            return { x, y, width, height };
        }

        // Function to Process Selection After Drawing
        function processSelection(rect) {
            const normalizedRect = normalizeRect(rect);
            // Calculate scaling factors based on the displayed image size
            const scaleX = uploadedImage.naturalWidth / overlayCanvas.width;
            const scaleY = uploadedImage.naturalHeight / overlayCanvas.height;

            // Convert rectangle coordinates back to natural image coordinates
            const imgRect = {
                x0: normalizedRect.x * scaleX,
                y0: normalizedRect.y * scaleY,
                x1: (normalizedRect.x + normalizedRect.width) * scaleX,
                y1: (normalizedRect.y + normalizedRect.height) * scaleY
            };

            // Find words inside the rectangle
            const wordsInRect = currentWords.filter(word => {
                return word.x0 >= imgRect.x0 && word.x1 <= imgRect.x1 &&
                       word.y0 >= imgRect.y0 && word.y1 <= imgRect.y1;
            });

            if (wordsInRect.length === 0) {
                alert('No words found within the selected area.');
                return;
            }

            // Combine texts of words in the rectangle
            const combinedText = wordsInRect.map(word => word.text).join(' ');

            // Determine the bounding box of the selected words
            const boundingBox = {
                x0: Math.min(...wordsInRect.map(w => w.x0)),
                y0: Math.min(...wordsInRect.map(w => w.y0)),
                x1: Math.max(...wordsInRect.map(w => w.x1)),
                y1: Math.max(...wordsInRect.map(w => w.y1))
            };

            // Convert bounding box back to canvas coordinates
            const canvasBoundingBox = {
                x: boundingBox.x0 / scaleX,
                y: boundingBox.y0 / scaleY,
                width: (boundingBox.x1 - boundingBox.x0) / scaleX,
                height: (boundingBox.y1 - boundingBox.y0) / scaleY
            };

            // Create a block object
            const block = {
                text: combinedText,
                x: canvasBoundingBox.x,
                y: canvasBoundingBox.y,
                width: canvasBoundingBox.width,
                height: canvasBoundingBox.height
            };

            // Add to selected blocks
            selectedBlocks.push(block);

            // Redraw the canvas to include the new block
            drawCanvasWithCurrentRect();

            statusMessage.textContent = 'Selection made. Click on the highlighted area to assign text to a field.';
        }

        // Function to Draw a Highlight Block
        function drawBlock(block) {
            const ctx = overlayCanvas.getContext('2d');
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0, 150, 255, 1)';
            ctx.fillStyle = 'rgba(0, 150, 255, 0.25)';
            ctx.fillRect(block.x, block.y, block.width, block.height);
            ctx.strokeRect(block.x, block.y, block.width, block.height);
        }

        // Function to Assign Block Text to a Field
        function assignBlockToField(text) {
            const choice = prompt(
                `Assign the selected text to a field:\n` +
                `1) Item Name Short\n` +
                `2) Item Name Long\n` +
                `3) UPC\n` +
                `4) Location\n` +
                `5) Downstack\n` +
                `6) Notes\n\n` +
                `Enter a number 1-6:`
            );
            if (!choice) return; // user canceled
            const num = parseInt(choice, 10);
            if (isNaN(num) || num < 1 || num > 6) {
                alert('Invalid choice.');
                return;
            }

            let targetField;
            switch (num) {
                case 1: targetField = field1; break;
                case 2: targetField = field2; break;
                case 3: targetField = field3; break;
                case 4: targetField = field4; break;
                case 5: targetField = field5; break;
                case 6: targetField = field6; break;
            }

            targetField.value = text;
        }

        // Function to Draw All Selected Blocks
        function drawAllBlocks() {
            clearCanvas();
            selectedBlocks.forEach(block => {
                drawBlock(block);
            });
        }

        // Function to Assign Words to Fields (Original Functionality)
        function assignWordToField(wordText) {
            const choice = prompt(
                `Choose a field to assign this text:\n` +
                `1) Item Name Short\n` +
                `2) Item Name Long\n` +
                `3) UPC\n` +
                `4) Location\n` +
                `5) Downstack\n` +
                `6) Notes\n\n` +
                `Enter a number 1-6:`
            );
            if (!choice) return; // user canceled
            const num = parseInt(choice, 10);
            if (isNaN(num) || num < 1 || num > 6) {
                alert('Invalid choice.');
                return;
            }

            let targetField;
            switch (num) {
                case 1: targetField = field1; break;
                case 2: targetField = field2; break;
                case 3: targetField = field3; break;
                case 4: targetField = field4; break;
                case 5: targetField = field5; break;
                case 6: targetField = field6; break;
            }

            targetField.value = wordText;
        }
    </script>
</body>
</html>
